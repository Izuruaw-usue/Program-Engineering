# Тема 8 : Введение в ООП

**Студент:** Джи Киянаге Исуру Анупама Викрамасингхе

**Группа:** ИВТ-23-1

## Таблица выполнения заданий

| № задания 8 | Лабораторная работа | Самостоятельнаяработа |
|-----------|------------| -----------|
| 1 | + | + |
| 2 | + |+ |
| 3 | + |+ |
| 4 | + |+ |
| 5 | + |+ |

# Лабораторная работа :  8

## Задание 1: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 1" src="https://github.com/user-attachments/assets/915b03c8-54eb-4d90-af7f-72bd08629850" />

**Вывод:**
Научился создавать классы как шаблоны для объектов, использовать конструктор __init__ для инициализации атрибутов, и создавать экземпляры классов (объекты) с конкретными значениями

## Задание 2: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 2" src="https://github.com/user-attachments/assets/07ec98d5-e433-40a2-8699-194dc5f09c03" />

**Вывод:** 
Научился добавлять методы в классы для описания поведения объектов, понимаю разницу между атрибутами (данные) и методами (действия)

## Задание 3: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 3" src="https://github.com/user-attachments/assets/021299b2-ca5b-4460-a3ff-d4a031ac8a06" />

**Вывод:**
Научился создавать дочерние классы, которые наследуют все атрибуты и методы от родительских классов, и использовать super() для вызова родительского конструктора

## Задание 4: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 4" src="https://github.com/user-attachments/assets/478b0b0e-feff-43b0-afd8-94f438903563" />

**Вывод:**
Научился управлять доступом к данным используя защищенные (_attr) и приватные (__attr) атрибуты, понимаю принципы сокрытия внутренней реализации

## Задание 5: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 5" src="https://github.com/user-attachments/assets/ce87cf15-f3e6-471a-9276-43a2e3700504" />

**Вывод:**
Научился создавать разные классы с одинаковыми методами, но разной реализацией, и работать с объектами разных классов через единый интерфейс



# Самостоятельная работа :  8

## Задание 1: 

**Код:**
```python
class Smartphone:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

my_phone = Smartphone("Samsung", "Galaxy S21")
print(f"Телефон: {my_phone.brand} {my_phone.model}")
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 1" src="https://github.com/user-attachments/assets/8c754ba5-2ed4-4bb8-ae44-ec51328631fd" />

**Вывод:**
Я научился создавать собственные классы с конструктором __init__, который инициализирует атрибуты объекта. Понял, как создавать экземпляры класса (объекты) и работать с их атрибутами. Это основа объектно-ориентированного программирования - возможность создавать пользовательские типы данных.

## Задание 2: 

**Код:**
```python
class Smartphone:
    def __init__(self, brand, model, storage):
        self.brand = brand
        self.model = model
        self.storage = storage
        self.is_on = False
    
    def turn_on(self):
        self.is_on = True
        print(f"{self.brand} {self.model} включен")
    
    def check_storage(self):
        print(f"Объем памяти: {self.storage}GB")

my_phone = Smartphone("Samsung", "Galaxy S21", 128)
my_phone.turn_on()
my_phone.check_storage()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 2" src="https://github.com/user-attachments/assets/9f7a9ae9-aa58-49b9-8f67-d94da70d46b9" />

**Вывод:**
Я понял, как добавлять методы к классам - это функции, которые определяют поведение объектов. Узнал о методах экземпляра, которые работают с данными конкретного объекта. Методы могут изменять состояние объекта (как turn_on) или просто возвращать информацию о нем (как check_storage).

## Задание 3: 

**Код:**
```python
class Smartphone:
    def __init__(self, brand, model, storage):
        self.brand = brand
        self.model = model
        self.storage = storage
        self.is_on = False

    def turn_on(self):
        self.is_on = True
        print(f"{self.brand} {self.model} включен")

    def check_storage(self):
        print(f"Объем памяти: {self.storage}GB")


class GamingPhone(Smartphone):
    def __init__(self, brand, model, storage, graphics_card):
        super().__init__(brand, model, storage)
        self.graphics_card = graphics_card

    def start_game(self):
        print(f"Запускаем игру на {self.brand} с видеокартой {self.graphics_card}")


my_gaming_phone = GamingPhone("ASUS", "ROG Phone", 256, "Adreno 650")
my_gaming_phone.turn_on()
my_gaming_phone.start_game()
my_gaming_phone.check_storage()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 3" src="https://github.com/user-attachments/assets/e53fa4d2-f0dd-4815-b481-c839c055b817" />

**Вывод:**
Я освоил концепцию наследования - создание нового класса на основе существующего. Понял, как использовать super() для вызова методов родительского класса, и как дочерние классы могут расширять функциональность родительских, добавляя новые атрибуты и методы. Это позволяет избежать дублирования кода.

## Задание 4: 

**Код:**
```python
class Smartphone:
    def __init__(self, brand, model, price):
        self._brand = brand 
        self._model = model  
        self.__price = price  
    
    def get_phone_info(self):
        return f"{self._brand} {self._model}"
    
    def get_discount_price(self, discount):
        return f"Цена со скидкой: {self.__price * (1 - discount/100)} руб."

my_phone = Smartphone("Xiaomi", "Redmi Note 10", 20000)
print(my_phone.get_phone_info())
print(my_phone.get_discount_price(10))
# print(my_phone.__price) 
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 4" src="https://github.com/user-attachments/assets/e985e634-44f6-4b3e-a9c7-4f71c9ce57e8" />

**Вывод:**
Я изучил инкапсуляцию - механизм сокрытия внутренней реализации класса. Понял разницу между защищенными (_атрибут) и приватными (__атрибут) атрибутами. Узнал, как контролировать доступ к данным класса и защищать важную информацию от прямого изменения извне, предоставляя доступ только через методы.


## Задание 5: 

**Код:**
```python
class Device:
    def get_description(self):
        pass

class Smartphone(Device):
    def __init__(self, brand, os):
        self.brand = brand
        self.os = os
    
    def get_description(self):
        return f"Смартфон {self.brand} на {self.os}"

class Tablet(Device):
    def __init__(self, brand, screen_size):
        self.brand = brand
        self.screen_size = screen_size
    
    def get_description(self):
        return f"Планшет {self.brand} с экраном {self.screen_size} дюймов"

devices = [
    Smartphone("Apple", "iOS"),
    Tablet("Samsung", 10.4)
]

for device in devices:
    print(device.get_description())
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 5" src="https://github.com/user-attachments/assets/00bb4f6d-daad-40cd-9af9-b39f1bce6d2f" />

**Вывод:**
Я освоил полиморфизм - возможность использовать объекты разных классов через общий интерфейс. Понял, как разные классы могут реализовывать один и тот же метод по-своему, и как это позволяет работать с разнотипными объектами единообразно. Это делает код более гибким и расширяемым.
