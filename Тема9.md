# Тема 9 : Концепции и принципы ООП

**Студент:** Джи Киянаге Исуру Анупама Викрамасингхе

**Группа:** ИВТ-23-1

## Таблица выполнения заданий

| № задания 9 | Лабораторная работа | Самостоятельнаяработа |
|-----------|------------| -----------|
|  |  | **Класс _Tomato_** |
| 1 | + |+ |
| 2 | + |+ |
| 3 | + |+ |
| 4 | + |+ |
| 5 | + |+ |
|  |  | **Класс _TomatoBush_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
|  |  | **Класс _Gardener_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
|  |  | **_Тесты_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
# Лабораторная работа :  9

## Задание 1: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 1" src="https://github.com/user-attachments/assets/0102c294-5c0c-4eb5-83fa-f4303830a03d" />

**Вывод:**
Я узнал, как использовать метод __init__, который является конструктором, для инициализации состояния объекта сразу после его создания. В данном случае он использовался для проверки ввода (проверка угаданного имени). Что более важно, я познакомился с атрибутом __slots__. Я узнал, что __slots__ явно объявляет элементы данных (атрибуты), которые может иметь класс. Это предотвращает создание __dict__ для каждого экземпляра, что экономит память. Ключевым выводом было наблюдение того, как это ограничивает динамическое создание новых атрибутов, что продемонстрировано ошибкой _AttributeError_ при попытке назначить _surname_.


## Задание 2: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 2" src="https://github.com/user-attachments/assets/e8c78369-befa-495d-9318-99eb7bbd0a2f" />

**Вывод:**
Эта часть научила меня добавлять поведение в класс с помощью методов. Я попрактиковался в написании метода (_check_composition_), который использует условную логику (_if/else_), чтобы изменить свой вывод в зависимости от состояния атрибутов объекта. Я также закрепил концепцию проверки типов внутри методов, чтобы гарантировать ожидаемое поведение программы, в данном случае — убедиться, что топпинг является строкой.


## Задание 3: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 3" src="https://github.com/user-attachments/assets/dd985f1b-77da-480a-b772-35e7554c923b" />

**Вывод:**
Здесь я усвоил концепцию инкапсуляции — объединение данных с методами, которые работают с этими данными. Я научился защищать внутреннее состояние объекта, делая атрибуты приватными (с использованием двойного подчеркивания __). Я реализовал метод геттера для безопасного чтения значения приватного атрибута и метод сеттера для его безопасного изменения, что позволяет при необходимости добавлять логику валидации. Я также увидел в действии метод деструктора __del__, который вызывается, когда объект удаляется сборщиком мусора. Наконец, я понял, почему прямой доступ к приватному атрибуту (obj.__name) завершается неудачей, обеспечивая таким образом защиту данных.


## Задание 4: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 4" src="https://github.com/user-attachments/assets/e96c7bf7-e50d-4ed4-8aba-4a2929372817" />

**Вывод:**
Это задание продемонстрировало силу наследования — механизма создания нового класса (дочернего или подкласса) из существующего (родительского или суперкласса). Я создал общий класс Mammal, а затем более конкретные классы Cat и Dog, которые наследовались от него. Я использовал функцию super() для вызова конструктора родительского класса. Ключевым моментом было понимание того, что наследование способствует повторному использованию кода (метод what_am_i определен только один раз) и позволяет расширять функциональность путем добавления уникальных атрибутов (sound для Cat, breed для Dog) в подклассах.

## Задание 5: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 5" src="https://github.com/user-attachments/assets/c1767bc4-9024-4c6c-a8eb-db69447c3236" />

**Вывод:**
В этой заключительной части я узнал о полиморфизме, который позволяет обращаться с объектами разных классов как с объектами общего суперкласса. Функция _how_do_you_greet_ может работать с любым объектом, у которого есть метод _greet()_, независимо от того, является ли он объектом Russian или English. Каждый объект "отвечает" по-разному в зависимости от своего класса, что и является сутью полиморфизма. Я также попрактиковался в использовании декоратора _@staticmethod_ для создания методов, которые принадлежат классу, а не экземпляру, и не требуют параметра _self_, что было уместно для метода _greet_ в данном контексте.


# Самостоятельная работа :  9

# Класс Tomato

## Задание 1: 

**Код:**
```python
class Tomato:
    pass
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomato 1" src="https://github.com/user-attachments/assets/3d9f4f19-b08a-4896-82aa-99a2b97aa672" />

**Вывод:**
Я научился создавать базовый класс с помощью ключевого слова _class_.

## Задание 2: 

**Код:**
```python
class Tomato:
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomato 2" src="https://github.com/user-attachments/assets/df0cf3f4-a78f-4d9b-9be0-9afe178cbf9e" />

**Вывод:**
Я узнал, как создавать статические свойства (атрибуты класса), которые принадлежат самому классу, а не его экземплярам, и являются общими для всех объектов.

## Задание 3: 

**Код:**
```python
class Tomato:
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}
    
    def __init__(self, index):
        self._index = index  # _index - защищенное свойство (protected)
        self._state = self.states[0] # _state - защищенное свойство (protected)
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomato 3" src="https://github.com/user-attachments/assets/47880098-30fe-4f29-934a-9ed02a9d15d5" />

**Вывод:**
Я понял принцип работы конструктора __init__ для инициализации экземпляров класса. Я также научился создавать защищенные атрибуты (с одним символом подчеркивания _), которые являются соглашением об их внутреннем использовании в классе.

## Задание 4: 

**Код:**
```python
class Tomato:
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}
    
    def __init__(self, index):
        self._index = index
        self._state = self.states[0]
    
    def grow(self):
        if self._state != self.states[3]:
            current_state_index = list(self.states.keys())[list(self.states.values()).index(self._state)]
            self._state = self.states[current_state_index + 1]
```

**Скриншот результата:**
<img width="1366" height="768" alt="self tomato 4" src="https://github.com/user-attachments/assets/59a81d93-fe6b-4ab4-ad79-c88fb6fde616" />

**Вывод:**
Я реализовал метод, который изменяет состояние объекта. Я научился работать со словарем стадий, находя текущую стадию и изменяя ее на следующую, тем самым реализовав "рост" помидора.

## Задание 5: 

**Код:**
```python
class Tomato:
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}
    
    def __init__(self, index):
        self._index = index
        self._state = self.states[0]
    
    def grow(self):
        if self._state != self.states[3]:
            current_state_index = list(self.states.keys())[list(self.states.values()).index(self._state)]
            self._state = self.states[current_state_index + 1]
    
    def is_ripe(self):
        return self._state == self.states[3]
```

**Скриншот результата:**
<img width="1366" height="768" alt="self tomato 5" src="https://github.com/user-attachments/assets/d7074331-d562-49ff-9077-3a83467b6a9e" />

**Вывод:**
Я создал метод, который возвращает булево значение (_True_/_False_). Этот метод инкапсулирует логику проверки условия (созрел ли помидор), что является хорошей практикой ООП.


# Class TomatoBush

## Задание 1: 

**Код:**
```python
class TomatoBush:
    pass
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomatobush 1" src="https://github.com/user-attachments/assets/2b4e20c2-f10c-4566-8f0c-76be2543a075" />

**Вывод:**
Я создал новый класс для представления куста с помидорами.

## Задание 2: 

**Код:**
```python
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomatobush 2" src="https://github.com/user-attachments/assets/eb520763-2a1c-4780-8ee8-ea17b7f158fe" />

**Вывод:**
 Я научился создавать композицию — объект класса _TomatoBush_ содержит в себе список объектов другого класса (_Tomato_). Это фундаментальная концепция ООП "has-a" (имеет).
 
## Задание 3: 

**Код:**
```python
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]
    
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomatobush 3" src="https://github.com/user-attachments/assets/064c0de3-73b4-43b2-92ab-65cd196d2d2a" />

**Вывод:**
Я реализовал метод, который делегирует вызов метода _grow()_ каждому объекту Tomato в списке. Это демонстрирует принцип управления объектами через их интерфейсы.

## Задание 4: 

**Код:**
```python
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]
    
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
    
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tomatobush 4" src="https://github.com/user-attachments/assets/eaf4d146-b708-41f3-8c90-f8128fd0caf1" />

**Вывод:**
Я применил встроенную функцию _all()_ для эффективной проверки условия для всех элементов коллекции. Это делает код чистым и читаемым.

## Задание 5: 

**Код:**
```python
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]
    
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
    
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)
    
    def give_away_all(self):
        self.tomatoes.clear()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self tomatobush 5" src="https://github.com/user-attachments/assets/d7db9bb6-7385-4bd0-ad05-1aa9308da59b" />

**Вывод:**
Я реализовал метод, который изменяет внутреннее состояние объекта (очищает список томатов), имитируя сбор урожая.

# Class Gardener

## Задание 1: 

**Код:**
```python
class Gardener:
    pass
```
**Скриншот результата:**
<img width="1366" height="768" alt="self gardner 1" src="https://github.com/user-attachments/assets/0c308028-f1e8-4295-b4b9-b76b10f827f1" />

**Вывод:**
Я создал класс для представления сущности "Садовник".

## Задание 2: 

**Код:**
```python
class Gardener:
    def __init__(self, name, plant):
        self.name = name  # name - публичное свойство (public)
        self._plant = plant # _plant - защищенное свойство (protected)
```
**Скриншот результата:**
<img width="1366" height="768" alt="self gardner 2" src="https://github.com/user-attachments/assets/def850d5-b31d-4cdb-aa0c-816805805a55" />

**Вывод:**
Я закрепил понимание создания защищенных и публичных атрибутов. Садовник "имеет" растение (__plant_), что является еще одним примером композиции.

## Задание 3: 

**Код:**
```python
class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant
    
    def work(self):
        self._plant.grow_all()
```
**Скриншот результата:**
<img width="1366" height="768" alt="self gardner 3" src="https://github.com/user-attachments/assets/a32acc18-aa6d-4b55-a4f9-bf013866ff1f" />

**Вывод:**
Я создал метод, который представляет действие садовника. Этот метод инкапсулирует вызов метода растения, демонстрируя взаимодействие между объектами разных классов.

## Задание 4: 

**Код:**
```python
class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant
    
    def work(self):
        self._plant.grow_all()
    
    def harvest(self):
        if self._plant.all_are_ripe():
            print("Урожай собран!")
            self._plant.give_away_all()
        else:
            print("Томаты еще не созрели! Нужно продолжать ухаживать.")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self gardner 4" src="https://github.com/user-attachments/assets/1ee1aa53-50d6-4a4a-aff7-525fb03df8f2" />

**Вывод:**
Я реализовал метод с условной логикой, который проверяет состояние связанного объекта (_TomatoBush_) и в зависимости от этого выполняет разные действия. Это ключевой метод для управления процессом.

## Задание 5: 

**Код:**
```python
class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant
    
    def work(self):
        self._plant.grow_all()
    
    def harvest(self):
        if self._plant.all_are_ripe():
            print("Урожай собран!")
            self._plant.give_away_all()
        else:
            print("Томаты еще не созрели! Нужно продолжать ухаживать.")
    
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: Помидоры созревают через несколько стадий: отсутствует, цветение, зеленый, красный.")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self gardner 5" src="https://github.com/user-attachments/assets/ab1ea2a8-5909-4e77-bcf5-0060d22ad414" />

**Вывод:**
Я научился создавать статические методы с помощью декоратора _@staticmethod_. Эти методы не требуют доступа к экземпляру (_self_) или классу (_cls_) и используются для утилитарных функций, логически связанных с классом.


# Тесты

## Задание 1: 

**Код:**
```python
print("=== ТЕСТ 1: Справка по садоводству ===")
Gardener.knowledge_base()
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tests 1" src="https://github.com/user-attachments/assets/fee646b4-2a63-40c6-8461-ffbc18bea849" />

**Вывод:**
Я вызвал статический метод непосредственно от класса, без создания его экземпляра.

## Задание 2: 

**Код:**
```python
print("\n=== ТЕСТ 2: Создание объектов ===")
bush = TomatoBush(3)
gardener = Gardener("Иван", bush)
print(f"Создан садовник {gardener.name} с кустом из {len(bush.tomatoes)} помидоров")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tests 2" src="https://github.com/user-attachments/assets/0cd8c1a1-7379-4918-b781-65483c7e92eb" />

**Вывод:**
Я создал экземпляры классов и связал их между собой, передав куст садовнику.

## Задание 3: 

**Код:**
```python
print("\n=== ТЕСТ 3: Первое ухаживание ===")
print("Первое ухаживание...")
gardener.work()
print("Состояние томатов после первого ухаживания:")
for i, tomato in enumerate(bush.tomatoes):
    print(f"Томат {i}: {tomato._state}")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tests 3" src="https://github.com/user-attachments/assets/a1474f67-f11c-453e-a082-16c0e9fd0fd7" />

**Вывод:**
Я использовал интерфейс объекта _gardener_ для воздействия на объект _bush_, что является примером делегирования.


## Задание 4: 

**Код:**
```python
print("\n=== ТЕСТ 4: Попытка сбора и дальнейшее ухаживание ===")
print("Попытка собрать урожай:")
gardener.harvest()

print("\nПродолжаем ухаживать...")
for i in range(2):
    gardener.work()
    print(f"После ухаживания {i+2}: {[tomato._state for tomato in bush.tomatoes]}")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tests 4" src="https://github.com/user-attachments/assets/b4514d0b-c099-444b-a96f-076b2f33ec79" />

**Вывод:**
Я протестировал логику программы, убедившись, что сбор урожая невозможен до полного созревания, и продемонстрировал необходимость многократного вызова метода _work()_.

## Задание 5: 

**Код:**
```python
print("\n=== ТЕСТ 5: Сбор урожая ===")
print("Проверяем готовность к сбору:")
gardener.harvest()
print(f"Количество томатов на кусте после сбора: {len(bush.tomatoes)}")
```
**Скриншот результата:**
<img width="1366" height="768" alt="self tests 5" src="https://github.com/user-attachments/assets/7a05d52c-10d6-4d1a-a66d-1335f8694f7e" />

**Вывод:**
Я успешно завершил цикл "рост -> проверка -> сбор", продемонстрировав корректную работу всей системы классов.

## Полный рабочий код для тестирования:

**Код:**
```python
class Tomato:
    states = {0: 'отсутствует', 1: 'цветение', 2: 'зеленый', 3: 'красный'}
    
    def __init__(self, index):
        self._index = index
        self._state = self.states[0]
    
    def grow(self):
        if self._state != self.states[3]:
            current_state_index = list(self.states.keys())[list(self.states.values()).index(self._state)]
            self._state = self.states[current_state_index + 1]
    
    def is_ripe(self):
        return self._state == self.states[3]

class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]
    
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
    
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)
    
    def give_away_all(self):
        self.tomatoes.clear()

class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant
    
    def work(self):
        self._plant.grow_all()
    
    def harvest(self):
        if self._plant.all_are_ripe():
            print("Урожай собран!")
            self._plant.give_away_all()
        else:
            print("Томаты еще не созрели! Нужно продолжать ухаживать.")
    
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: Помидоры созревают через несколько стадий: отсутствует, цветение, зеленый, красный.")

# ТЕСТ 1
print("=== ТЕСТ 1 ===")
Gardener.knowledge_base()

# ТЕСТ 2
print("\n=== ТЕСТ 2 ===")
bush = TomatoBush(3)
gardener = Gardener("Иван", bush)
print("Объекты созданы")

# ТЕСТ 3
print("\n=== ТЕСТ 3 ===")
gardener.work()
print("Ухаживание завершено")

# ТЕСТ 4
print("\n=== ТЕСТ 4 ===")
gardener.harvest()
gardener.work()
gardener.work()
print("Дополнительные ухаживания завершены")

# ТЕСТ 5
print("\n=== ТЕСТ 5 ===")
gardener.harvest()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self full code for tests" src="https://github.com/user-attachments/assets/a2bd3fb0-21ac-4c85-ab41-0e03b28a38e9" />









