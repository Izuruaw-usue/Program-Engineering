# Тема 9 : Концепции и принципы ООП

**Студент:** Джи Киянаге Исуру Анупама Викрамасингхе

**Группа:** ИВТ-23-1

## Таблица выполнения заданий

| № задания 9 | Лабораторная работа | Самостоятельнаяработа |
|-----------|------------| -----------|
|  |  | **Класс _Tomato_** |
| 1 | + |+ |
| 2 | + |+ |
| 3 | + |+ |
| 4 | + |+ |
| 5 | + |+ |
|  |  | **Класс _TomatoBush_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
|  |  | **Класс _Gardener_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
|  |  | **_Тесты_** |
| 1 | None |+ |
| 2 | None |+ |
| 3 | None |+ |
| 4 | None |+ |
| 5 | None |+ |
# Лабораторная работа :  9

## Задание 1: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 1" src="https://github.com/user-attachments/assets/0102c294-5c0c-4eb5-83fa-f4303830a03d" />

**Вывод:**
Я узнал, как использовать метод __init__, который является конструктором, для инициализации состояния объекта сразу после его создания. В данном случае он использовался для проверки ввода (проверка угаданного имени). Что более важно, я познакомился с атрибутом __slots__. Я узнал, что __slots__ явно объявляет элементы данных (атрибуты), которые может иметь класс. Это предотвращает создание __dict__ для каждого экземпляра, что экономит память. Ключевым выводом было наблюдение того, как это ограничивает динамическое создание новых атрибутов, что продемонстрировано ошибкой _AttributeError_ при попытке назначить _surname_.


## Задание 2: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 2" src="https://github.com/user-attachments/assets/e8c78369-befa-495d-9318-99eb7bbd0a2f" />

**Вывод:**
Эта часть научила меня добавлять поведение в класс с помощью методов. Я попрактиковался в написании метода (_check_composition_), который использует условную логику (_if/else_), чтобы изменить свой вывод в зависимости от состояния атрибутов объекта. Я также закрепил концепцию проверки типов внутри методов, чтобы гарантировать ожидаемое поведение программы, в данном случае — убедиться, что топпинг является строкой.


## Задание 3: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 3" src="https://github.com/user-attachments/assets/dd985f1b-77da-480a-b772-35e7554c923b" />

**Вывод:**
Здесь я усвоил концепцию инкапсуляции — объединение данных с методами, которые работают с этими данными. Я научился защищать внутреннее состояние объекта, делая атрибуты приватными (с использованием двойного подчеркивания __). Я реализовал метод геттера для безопасного чтения значения приватного атрибута и метод сеттера для его безопасного изменения, что позволяет при необходимости добавлять логику валидации. Я также увидел в действии метод деструктора __del__, который вызывается, когда объект удаляется сборщиком мусора. Наконец, я понял, почему прямой доступ к приватному атрибуту (obj.__name) завершается неудачей, обеспечивая таким образом защиту данных.


## Задание 4: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 4" src="https://github.com/user-attachments/assets/e96c7bf7-e50d-4ed4-8aba-4a2929372817" />

**Вывод:**
Это задание продемонстрировало силу наследования — механизма создания нового класса (дочернего или подкласса) из существующего (родительского или суперкласса). Я создал общий класс Mammal, а затем более конкретные классы Cat и Dog, которые наследовались от него. Я использовал функцию super() для вызова конструктора родительского класса. Ключевым моментом было понимание того, что наследование способствует повторному использованию кода (метод what_am_i определен только один раз) и позволяет расширять функциональность путем добавления уникальных атрибутов (sound для Cat, breed для Dog) в подклассах.

## Задание 5: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 5" src="https://github.com/user-attachments/assets/c1767bc4-9024-4c6c-a8eb-db69447c3236" />

**Вывод:**
В этой заключительной части я узнал о полиморфизме, который позволяет обращаться с объектами разных классов как с объектами общего суперкласса. Функция _how_do_you_greet_ может работать с любым объектом, у которого есть метод _greet()_, независимо от того, является ли он объектом Russian или English. Каждый объект "отвечает" по-разному в зависимости от своего класса, что и является сутью полиморфизма. Я также попрактиковался в использовании декоратора _@staticmethod_ для создания методов, которые принадлежат классу, а не экземпляру, и не требуют параметра _self_, что было уместно для метода _greet_ в данном контексте.

